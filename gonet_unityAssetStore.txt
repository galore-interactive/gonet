GONet

<bold>NOTE: Unity GONet package is now available since UNET is deprecated/obsolete and in its end-of-life long term support (LTS) cycle. This version here on the Asset Store is the most recent, it does have the newest features and will continue to be supported.</bold>

GONet is the Unity3D GameObject Networking solution with tight, developer-friendly integration into all things Unity.  GONet is part of the Networked-by-Default and Performance-by-Default initiatives!  Written with an extensive history of Unity game development team experience, collaboration and feedback.  GONet makes the most difficult aspects of multi-player game development approachable so you can deliver your game to the world in a timely manner with confidence.  With hindsight 20/20 on our side, GONet is now less restrictive, less steps to "get going" and planely mo' betta than UNET!

<bold>*** Instead of runtime reflection or error-prone/confusing byte weaving, GONet utilizes (automatic) design-time code generation that is runtime debuggable. Unity-friendly multi-threading where appropriate. Works well with default settings, but tweak away if you want. REPLAY support is out of the box!  And the box is not black, as source code is included.</bold>

- <bold>Auto-magical data sync:</bold>
 \-> Transform - position/localPosition, rotation/localRotation, scale
 \-> Animator Controller parameters
 \-> Any MonoBehaviour fields ([SyncVar] replacement)
 \-> GameObject.Instantiate() is auto-magically networked from the owner/instantiator to all interested parties/machines (optionally use a prefab alternate for non-owners)
 \-> Sync settings applied to groups of data items: default and/or user-defined (via profiles/templates)
 \-> Auto-magically blend between received values for non-owners: default interpolation/extrapolation and/or user-defined implementation
- <bold>Event Bus:</bold>
 \-> Publish and subscribe to omni-directional ("arbitrary" content) communication  ([Command], [ClientRpc] and [TargetRpc] replacement)
 \-> Transient events - delivered to clients connected to game session when event occurs
 \-> Persistent events - like Transient event with additional delivery to any clients connecting to the game session after event occurs and will exist in recorded/replay data
 \-> Any user-defined event class - can be either transient or persistent
 \-> Promotes industry proven event-driven game architecture and facilitates GONet Record+Replay
- <bold>Serialization options:</bold>
 \-> Default Auto-magical data sync:  custom bit packing (with LZ4 compression)
 \-> Default Event Bus traffic: MessagePack (with LZ4 compression)
 \-> User-defined custom overrides: if you have special cases or feel you can do it better, by all means, we provide a mechanism to do so
 \-> Configurable value quantization: choose # bits to occupy and auto-magically quantizes/compresses to fit (great for LOD)
- <bold>Record+Replay GONet sessions:</bold>
 \-> Everything GONet sends is recorded
 \-> Replay is great for: development troubleshooting, (eSports) instant replay, Location Based Entertainment takeaway
 \-> Recorded session data feeds into time series, statistics-based graphs for analysis during development and perhaps more importantly after game is released
- <bold>Level of Detail (LOD) management:</bold>
 \-> Control the Who/What/When/Where/Why/How of data detail
 \-> Default implementation uses distance to client's main player controlled GameObject (closer = high data resolution, further = lower data resolution...down to excluded entirely)
 \-> User-defined custom overrides: decide what causes changes to a GameObject's data LOD, when it should be applied, how much it affects LOD, etc...
- <bold>Wide platform/runtime support</bold>
 \-> All managed C#, no native libraries
 \-> Ahead of Time (AOT) compilation support (e.g., iOS)
 \-> IL2CPP (belongs in ?????? category below)
- <bold>Network Protocols</bold>
 \-> UDP (unreliable)
 \-> RUDP (reliable+ordered UDP)
 \-> Configurable channels

??????
- <bold>Networking goodies:</bold>
 \-> Lag compensation
 \-> Client-side prediction (i.e., extrapolation? got this up top, if so)
 \-> Interpolation (got this up top)
 \-> Delta compression (can accomplish with recorded send data....need to add recorded received too..share then reconcile?)
- <bold>Network topologies:</bold>
 \-> Dedicated game server (client-server DGS) *** definitely this one!
 \-> Local ("couch multiplayer"): multiple players/inputs/viewport on same machine *** this means multiple client instances in same process...maybe not this one!
 \-> Local (LAN): location-based entertainment (LBE) *** definitely this one..as it is an implementation of DGS!
 \-> Peer-to-Peer (P2P) *** highly motivated to get this one
 \-> Client-Server Host (client-server) - needs host migration impl!
??????

Let GONet take on the most difficult burden you face, so your team can focus on interesting creative matters.  GONet integrates nicely into existing game project code bases and effortlessly for those lucky to be in green field development.

Manual and API Documentation 
Please discuss GONet in the forum
Contact support to discuss consulting assistance for implementation/integration/migration with your game project team.  We will help you from getting off the ground up to crossing the finish line with you.








================
Code Generation:
================
What can happen in order to cause regeneration to occur when saving level or playing in editor?
1) 