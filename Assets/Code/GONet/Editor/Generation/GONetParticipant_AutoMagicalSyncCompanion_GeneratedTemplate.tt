<#@ template debug="false" hostspecific="false" language="C#" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="$(ProjectDir)Library\ScriptAssemblies\Assembly-CSharp.dll" #>
<#@ assembly name="$(ProjectDir)Library\ScriptAssemblies\Assembly-CSharp-Editor.dll" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="GONet" #>
<#@ import namespace="GONet.Utils" #>
<#@ import namespace="GONet.Generation" #>

using System;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using GONet;

namespace GONet.Generation
{
	internal sealed class <#=ClassName#> : GONetParticipant_AutoMagicalSyncCompanion_Generated
    {
<#
	int overallCount = 0;
	Array.ForEach(uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName, uE => overallCount += uE.autoSyncMembers.Length);

	int singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
#>
		private <#=single.componentTypeFullName#> _<#=single.componentTypeName#>;
		internal <#=single.componentTypeFullName#> <#=single.componentTypeName#>
		{
			get
			{
				if ((object)_<#=single.componentTypeName#> == null)
				{
					_<#=single.componentTypeName#> = gonetParticipant.GetComponent<<#=single.componentTypeFullName#>>();
				}
				return _<#=single.componentTypeName#>;
			}
		}

<#	}#>

        internal <#=ClassName#>(GONetParticipant gonetParticipant) : base(gonetParticipant)
		{
			valuesCount = <#=overallCount#>;
		    
			lastKnownValueChangesSinceLastCheck = lastKnownValuesChangedArrayPool.Borrow((int)valuesCount);
			Array.Clear(lastKnownValueChangesSinceLastCheck, 0, lastKnownValueChangesSinceLastCheck.Length);

			valuesChangesSupport = valuesChangesSupportArrayPool.Borrow((int)valuesCount);
			
<#
	int iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
			var support<#=iOverall#> = valuesChangesSupport[<#=iOverall#>] = valueChangeSupportArrayPool.Borrow();
            support<#=iOverall#>.lastKnownValue = <#=single.componentTypeName#>.<#=singleMember.memberName#>; // IMPORTANT: The use of the property here (i.e., prior to use anywhere herein after) ensures GetComponnet<T>() called up front and that component is cached and available subsequently as needed/referenced/used
            support<#=iOverall#>.lastKnownValue_previous = <#=single.componentTypeName#>.<#=singleMember.memberName#>; // IMPORTANT: same as above PLUS capturing the initial value now as the previous will ensure we do not accumulate changes during first pass "has anything changed" checks, which caused some problems before putting this in because things run in different threads and this is appropriate!
			support<#=iOverall#>.syncCompanion = this;
			support<#=iOverall#>.index = <#=iOverall#>;
			support<#=iOverall#>.syncAttribute_ProcessingPriority = <#=singleMember.attribute.ProcessingPriority#>;
			support<#=iOverall#>.syncAttribute_ProcessingPriority_GONetInternalOverride = <#=singleMember.attribute.ProcessingPriority_GONetInternalOverride#>;
			support<#=iOverall#>.syncAttribute_SyncChangesEverySeconds = <#=singleMember.attribute.SyncChangesEverySeconds#>f;
			support<#=iOverall#>.syncAttribute_Reliability = AutoMagicalSyncReliability.<#=singleMember.attribute.Reliability#>;
			support<#=iOverall#>.syncAttribute_ShouldBlendBetweenValuesReceived = <#=singleMember.attribute.ShouldBlendBetweenValuesReceived ? "true" : "false"#>;
			support<#=iOverall#>.syncAttribute_QuantizerSettingsGroup = new GONet.Utils.QuantizerSettingsGroup(<#=singleMember.attribute.QuantizeLowerBound == float.MinValue ? "float.MinValue" : singleMember.attribute.QuantizeLowerBound.ToString() + "f"#>, <#=singleMember.attribute.QuantizeUpperBound == float.MaxValue ? "float.MaxValue" : singleMember.attribute.QuantizeUpperBound.ToString() + "f"#>, <#=singleMember.attribute.QuantizeDownToBitCount#>, true);
<#			if (singleMember.attribute.	ShouldBlendBetweenValuesReceived)
            {#>		
            int support<#=iOverall#>_mostRecentChanges_calcdSize = support<#=iOverall#>.syncAttribute_SyncChangesEverySeconds != 0 ? (int)((GONetMain.BLENDING_BUFFER_LEAD_SECONDS / support<#=iOverall#>.syncAttribute_SyncChangesEverySeconds) * 2.5f) : 0;
            support<#=iOverall#>.mostRecentChanges_capacitySize = Math.Max(support<#=iOverall#>_mostRecentChanges_calcdSize, GONetMain.AutoMagicalSync_ValueMonitoringSupport_ChangedValue.MOST_RECENT_CHANGEs_SIZE_MINIMUM);
			support<#=iOverall#>.mostRecentChanges = GONetMain.AutoMagicalSync_ValueMonitoringSupport_ChangedValue.mostRecentChangesPool.Borrow(support<#=iOverall#>.mostRecentChanges_capacitySize);
<#			}#>

<#
			iOverall++;
		}
	}
#>
		}

        internal override void SetAutoMagicalSyncValue(byte index, object value)
		{
			switch (index)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall++#>:
					<#=single.componentTypeName#>.<#=singleMember.memberName#> = (<#=singleMember.memberTypeFullName#>)value;
					return;
<#		}
	}
#>
			}
		}

        internal override object GetAutoMagicalSyncValue(byte index)
		{
			switch (index)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall++#>:
					return <#=single.componentTypeName#>.<#=singleMember.memberName#>;
<#		}
	}
#>
			}

			return null;
		}

        /// <summary>
        /// Serializes all values of appropriaate member variables internally to <paramref name="bitStream_appendTo"/>.
        /// Oops.  Just kidding....it's ALMOST all values.  The exception being <see cref="GONetParticipant.GONetId"/> because that has to be processed first separately in order
        /// to know which <see cref="GONetParticipant"/> we are working with in order to call this method.
        /// </summary>
        internal override void SerializeAll(Utils.BitStream bitStream_appendTo)
        {
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		int iSingleMemberStart = 0;
		if (single.componentTypeFullName == typeof(GONetParticipant).FullName)
        {
			iSingleMemberStart = 1; // IMPORTANT: purposefully skipping over 0 index which is ASSuMEd to be GONetId as that is handled separately/first in the method that calls this one
			++iOverall; // since we skip one, we have to increment this bad boy too or else things can get off elsewhere
        }
		for (int iSingleMember = iSingleMemberStart; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
			{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
				IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
				customSerializer.Serialize(bitStream_appendTo, gonetParticipant, <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
				bitStream_appendTo.WriteBit(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
					if (singleMember.attribute.QuantizeDownToBitCount > 0)
                    {
#>
				SerializeSingleQuantized(bitStream_appendTo, <#=iOverall#>, <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
                    }
					else
                    {
#>
				bitStream_appendTo.WriteFloat(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
                    }
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
				bitStream_appendTo.WriteLong(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
				bitStream_appendTo.WriteUInt(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
                bitStream_appendTo.WriteString(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
				bitStream_appendTo.WriteByte(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
				bitStream_appendTo.WriteUShort(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName
				 || singleMember_memberTypeFullName == typeof(int).FullName
				 || singleMember_memberTypeFullName == typeof(sbyte).FullName
				 || singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
				byte[] bytes = BitConverter.GetBytes(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
				int count = bytes.Length;
				for (int i = 0; i < count; ++i)
				{
					bitStream_appendTo.WriteByte(bytes[i]);
				}
<#
				}
			}#>
			}
<#			++iOverall;
		}
	}
#>
			
			base.SerializeAll(bitStream_appendTo); // I know.  I know.  OOP says call base first.  Well, we need ours to go last to ensure some prerequsite values are set prior to know what needs doing (e.g., IsRotationSyncd?)
        }

        internal override void SerializeSingle(Utils.BitStream bitStream_appendTo, byte singleIndex)
        {
			switch (singleIndex)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall#>:
				{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
					IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
					customSerializer.Serialize(bitStream_appendTo, gonetParticipant, <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
					bitStream_appendTo.WriteBit(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
					if (singleMember.attribute.QuantizeDownToBitCount > 0)
                    {
#>
					SerializeSingleQuantized(bitStream_appendTo, <#=iOverall#>, <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
                    }
					else
                    {
#>
					bitStream_appendTo.WriteFloat(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
                    }
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
					bitStream_appendTo.WriteLong(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
					bitStream_appendTo.WriteUInt(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
					bitStream_appendTo.WriteString(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
					bitStream_appendTo.WriteByte(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
					bitStream_appendTo.WriteUShort(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName
				 || singleMember_memberTypeFullName == typeof(int).FullName
				 || singleMember_memberTypeFullName == typeof(sbyte).FullName
				 || singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
					byte[] bytes = BitConverter.GetBytes(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
					int count = bytes.Length;
					for (int i = 0; i < count; ++i)
					{
						bitStream_appendTo.WriteByte(bytes[i]);
					}
<#
				}
			}#>
				}
				break;

<#			++iOverall;
		}
	}
#>
			}
        }

        /// <summary>
        /// Deserializes all values from <paramref name="bitStream_readFrom"/> and uses them to modify appropriate member variables internally.
        /// Oops.  Just kidding....it's ALMOST all values.  The exception being <see cref="GONetParticipant.GONetId"/> because that has to be processed first separately in order
        /// to know which <see cref="GONetParticipant"/> we are working with in order to call this method.
        /// </summary>
        internal override void DeserializeInitAll(Utils.BitStream bitStream_readFrom, long assumedElapsedTicksAtChange)
        {
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		int iSingleMemberStart = 0;
		if (single.componentTypeFullName == typeof(GONetParticipant).FullName)
        {
			iSingleMemberStart = 1; // IMPORTANT: purposefully skipping over 0 index which is ASSuMEd to be GONetId as that is handled separately/first in the method that calls this one
			++iOverall; // since we skip one, we have to increment this bad boy too or else things can get off elsewhere
        }
		for (int iSingleMember = iSingleMemberStart; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
			{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
				IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = (<#=singleMember.memberTypeFullName#>)customSerializer.Deserialize(bitStream_readFrom);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
				bool value;
                bitStream_readFrom.ReadBit(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
#>
				float value;
<#				
					if (singleMember.attribute.QuantizeDownToBitCount > 0)
                    {
#>
				value = (float)DeserializeSingleQuantized(bitStream_readFrom, <#=iOverall#>);
<#
                    }
					else
                    {
#>
                bitStream_readFrom.ReadFloat(out value);
<#
                    }
#>
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
				long value;
                bitStream_readFrom.ReadLong(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
				uint value;
                bitStream_readFrom.ReadUInt(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
				string value;
                bitStream_readFrom.ReadString(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = (byte)bitStream_readFrom.ReadByte();
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
				ushort value;
                bitStream_readFrom.ReadUShort(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName)
				{
#>
				int count = 2;
				byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
				for (int i = 0; i < count; ++i)
				{
					byte b = (byte)bitStream_readFrom.ReadByte();
					bytes[i] = b;
				}
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = BitConverter.ToInt16(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(int).FullName)
				{
#>
				int count = 4;
				byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
				for (int i = 0; i < count; ++i)
				{
					byte b = (byte)bitStream_readFrom.ReadByte();
					bytes[i] = b;
				}
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = BitConverter.ToInt32(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(sbyte).FullName)
				{
#>
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = (sbyte)bitStream_readFrom.ReadByte();
<#
				}
                else if (singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
				int count = 8;
				byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
				for (int i = 0; i < count; ++i)
				{
					byte b = (byte)bitStream_readFrom.ReadByte();
					bytes[i] = b;
				}
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = BitConverter.ToDouble(bytes, 0);
<#
				}
			}#>
			}
<#			++iOverall;
		}
	}
#>
			
			base.DeserializeInitAll(bitStream_readFrom, assumedElapsedTicksAtChange); // I know.  I know.  OOP says call base first.  Well, we need ours to go last to ensure some prerequsite values are set prior to know what needs doing (e.g., IsRotationSyncd?)
        }

        /// <summary>
        ///  Deserializes a single value (using <paramref name="singleIndex"/> to know which) from <paramref name="bitStream_readFrom"/>
        ///  and uses them to modify appropriate member variables internally.
        /// </summary>
        internal override void DeserializeInitSingle(Utils.BitStream bitStream_readFrom, byte singleIndex, long assumedElapsedTicksAtChange)
        {
			switch (singleIndex)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall#>:
				{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
					IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
					var value = (<#=singleMember.memberTypeFullName#>)customSerializer.Deserialize(bitStream_readFrom);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
					bool value;
					bitStream_readFrom.ReadBit(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
#>
					float value;
<#				
					if (singleMember.attribute.QuantizeDownToBitCount > 0)
                    {
#>
					value = (float)DeserializeSingleQuantized(bitStream_readFrom, <#=iOverall#>);
<#
                    }
					else
                    {
#>
					bitStream_readFrom.ReadFloat(out value);
<#
                    }
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
					long value;
					bitStream_readFrom.ReadLong(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
					uint value;
					bitStream_readFrom.ReadUInt(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
					string value;
					bitStream_readFrom.ReadString(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
					var value = (byte)bitStream_readFrom.ReadByte();
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
					ushort value;
					bitStream_readFrom.ReadUShort(out value);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName)
				{
#>
					int count = 2;
					byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
					for (int i = 0; i < count; ++i)
					{
						byte b = (byte)bitStream_readFrom.ReadByte();
						bytes[i] = b;
					}
					var value = BitConverter.ToInt16(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(int).FullName)
				{
#>
					int count = 4;
					byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
					for (int i = 0; i < count; ++i)
					{
						byte b = (byte)bitStream_readFrom.ReadByte();
						bytes[i] = b;
					}
					var value = BitConverter.ToInt32(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(sbyte).FullName)
				{
#>
					var value = (sbyte)bitStream_readFrom.ReadByte();
<#
				}
                else if (singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
					int count = 8;
					byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
					for (int i = 0; i < count; ++i)
					{
						byte b = (byte)bitStream_readFrom.ReadByte();
						bytes[i] = b;
					}
					var value = BitConverter.ToDouble(bytes, 0);
<#
				}
			}#>
<#				if (singleMember.attribute.ShouldBlendBetweenValuesReceived)
				{#>
					valuesChangesSupport[<#=iOverall#>].AddToMostRecentChangeQueue_IfAppropriate((float)value, assumedElapsedTicksAtChange); // NOTE: this queue will be used each frame to blend between this value and others added there
<#				}
				else
				{#>
					<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#				}#>
				}
				break;

<#			++iOverall;
		}
	}
#>
			}
        }

		internal override void UpdateLastKnownValues(GONetMain.SyncBundleUniqueGrouping? onlyMatchIfUniqueGroupingMatches = default)
		{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				var valuesChangesSupport<#=iOverall#> = valuesChangesSupport[<#=iOverall#>];
				if (DoesMatchUniqueGrouping(valuesChangesSupport<#=iOverall#>, onlyMatchIfUniqueGroupingMatches))
				{
					valuesChangesSupport<#=iOverall#>.lastKnownValue_previous = valuesChangesSupport<#=iOverall#>.lastKnownValue;
					valuesChangesSupport<#=iOverall#>.lastKnownValue = <#=single.componentTypeName#>.<#=singleMember.memberName#>;
				}

<#		
			iOverall++;
		}
	}
#>
		}
    }
}
