<#@ template debug="false" hostspecific="false" language="C#" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="$(ProjectDir)Library\ScriptAssemblies\Assembly-CSharp.dll" #>
<#@ assembly name="$(ProjectDir)Library\ScriptAssemblies\Assembly-CSharp-Editor.dll" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="GONet" #>
<#@ import namespace="GONet.Utils" #>
<#@ import namespace="GONet.Generation" #>

using System;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using GONet;

namespace GONet.Generation
{
	internal sealed class <#=ClassName#> : GONetParticipant_AutoMagicalSyncCompanion_Generated
    {
<#
	int overallCount = 0;
	Array.ForEach(uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName, uE => overallCount += uE.autoSyncMembers.Length);

	int singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
#>
		private <#=single.componentTypeFullName#> _<#=single.componentTypeName#>;
		internal <#=single.componentTypeFullName#> <#=single.componentTypeName#>
		{
			get
			{
				if ((object)_<#=single.componentTypeName#> == null)
				{
					_<#=single.componentTypeName#> = gonetParticipant.GetComponent<<#=single.componentTypeFullName#>>();
				}
				return _<#=single.componentTypeName#>;
			}
		}

<#	}#>

        internal <#=ClassName#>(GONetParticipant gonetParticipant) : base(gonetParticipant)
		{
			valuesCount = <#=overallCount#>;
		    
			lastKnownValueChangesSinceLastCheck = lastKnownValuesChangedArrayPool.Borrow((int)valuesCount);
			Array.Clear(lastKnownValueChangesSinceLastCheck, 0, lastKnownValueChangesSinceLastCheck.Length);

			valuesChangesSupport = valuesChangesSupportArrayPool.Borrow((int)valuesCount);
			
<#
	int iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
			var support<#=iOverall#> = valuesChangesSupport[<#=iOverall#>] = valueChangeSupportArrayPool.Borrow();
            support<#=iOverall#>.lastKnownValue = default(<#=singleMember.memberTypeFullName#>);
            support<#=iOverall#>.lastKnownValue_previous = default(<#=singleMember.memberTypeFullName#>);
			support<#=iOverall#>.syncCompanion = this;
			support<#=iOverall#>.index = <#=iOverall#>;
			support<#=iOverall#>.syncAttribute_ProcessingPriority = <#=singleMember.attribute.ProcessingPriority#>;
			support<#=iOverall#>.syncAttribute_ProcessingPriority_GONetInternalOverride = <#=singleMember.attribute.ProcessingPriority_GONetInternalOverride#>;
			support<#=iOverall#>.syncAttribute_SyncChangesEverySeconds = <#=singleMember.attribute.SyncChangesEverySeconds#>f;
			support<#=iOverall#>.syncAttribute_Reliability = AutoMagicalSyncReliability.<#=singleMember.attribute.Reliability#>;
			support<#=iOverall#>.syncAttribute_ShouldBlendBetweenValuesReceived = <#=singleMember.attribute.ShouldBlendBetweenValuesReceived ? "true" : "false"#>;
<#			if (singleMember.attribute.	ShouldBlendBetweenValuesReceived)
            {#>		
			support<#=iOverall#>.mostRecentChanges = GONetMain.AutoMagicalSync_ValueMonitoringSupport_ChangedValue.mostRecentChangesPool.Borrow(GONetMain.AutoMagicalSync_ValueMonitoringSupport_ChangedValue.MOST_RECENT_CHANGEs_SIZE);
<#			}#>
			var dummyToEnsureGetterCalledOnceBeforeHeatOfBattle<#=iOverall#> = <#=single.componentTypeName#>; // let's ensure GetComponnet<T>() called up front

<#
			iOverall++;
		}
	}
#>
		}

        internal override void SetAutoMagicalSyncValue(byte index, object value)
		{
			switch (index)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall++#>:
					<#=single.componentTypeName#>.<#=singleMember.memberName#> = (<#=singleMember.memberTypeFullName#>)value;
					return;
<#		}
	}
#>
			}
		}

        internal override object GetAutoMagicalSyncValue(byte index)
		{
			switch (index)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall++#>:
					return <#=single.componentTypeName#>.<#=singleMember.memberName#>;
<#		}
	}
#>
			}

			return null;
		}

        internal override void SerializeAll(Utils.BitStream bitStream_appendTo)
        {
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
			{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
				IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
				customSerializer.Serialize(bitStream_appendTo, gonetParticipant, <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
				bitStream_appendTo.WriteBit(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
#>
				bitStream_appendTo.WriteFloat(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
				bitStream_appendTo.WriteLong(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
				bitStream_appendTo.WriteUInt(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
                bitStream_appendTo.WriteString(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
				bitStream_appendTo.WriteByte(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
				bitStream_appendTo.WriteUShort(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName
				 || singleMember_memberTypeFullName == typeof(int).FullName
				 || singleMember_memberTypeFullName == typeof(sbyte).FullName
				 || singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
				byte[] bytes = BitConverter.GetBytes(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
				int count = bytes.Length;
				for (int i = 0; i < count; ++i)
				{
					bitStream_appendTo.WriteByte(bytes[i]);
				}
<#
				}
			}#>
			}
<#		}
	}
#>
        }

        internal override void SerializeSingle(Utils.BitStream bitStream_appendTo, byte singleIndex)
        {
			switch (singleIndex)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall#>:
				{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
					IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
					customSerializer.Serialize(bitStream_appendTo, gonetParticipant, <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
					bitStream_appendTo.WriteBit(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
#>
					bitStream_appendTo.WriteFloat(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
					bitStream_appendTo.WriteLong(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
					bitStream_appendTo.WriteUInt(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
					bitStream_appendTo.WriteString(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
					bitStream_appendTo.WriteByte(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
					bitStream_appendTo.WriteUShort(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName
				 || singleMember_memberTypeFullName == typeof(int).FullName
				 || singleMember_memberTypeFullName == typeof(sbyte).FullName
				 || singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
					byte[] bytes = BitConverter.GetBytes(<#=single.componentTypeName#>.<#=singleMember.memberName#>);
					int count = bytes.Length;
					for (int i = 0; i < count; ++i)
					{
						bitStream_appendTo.WriteByte(bytes[i]);
					}
<#
				}
			}#>
				}
				break;

<#			++iOverall;
		}
	}
#>
			}
        }

        /// <summary>
        ///  Deserializes all values from <paramref name="bitStream_readFrom"/> and uses them to modify appropriate member variables internally.
        /// </summary>
        internal override void DeserializeInitAll(Utils.BitStream bitStream_readFrom, long assumedElapsedTicksAtChange)
        {
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
			{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
				IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = (<#=singleMember.memberTypeFullName#>)customSerializer.Deserialize(bitStream_readFrom);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
<#					if (singleMember.isField) {#>
                bitStream_readFrom.ReadBit(out <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#					} else {#>
				bool value;
                bitStream_readFrom.ReadBit(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#					}#>
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
#>
<#					if (singleMember.isField) {#>
                bitStream_readFrom.ReadFloat(out <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#					} else {#>
				float value;
                bitStream_readFrom.ReadFloat(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#					}#>
<#
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
<#					if (singleMember.isField) {#>
                bitStream_readFrom.ReadLong(out <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#					} else {#>
				long value;
                bitStream_readFrom.ReadLong(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#					}#>
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
<#					if (singleMember.isField) {#>
                bitStream_readFrom.ReadUInt(out <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#					} else {#>
				uint value;
                bitStream_readFrom.ReadUInt(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#					}#>
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
<#					if (singleMember.isField) {#>
                bitStream_readFrom.ReadString(out <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#					} else {#>
				string value;
                bitStream_readFrom.ReadString(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#					}#>
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = (byte)bitStream_readFrom.ReadByte();
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
<#					if (singleMember.isField) {#>
                bitStream_readFrom.ReadUShort(out <#=single.componentTypeName#>.<#=singleMember.memberName#>);
<#					} else {#>
				ushort value;
                bitStream_readFrom.ReadUShort(out value);
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#					}#>
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName)
				{
#>
				int count = 2;
				byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
				for (int i = 0; i < count; ++i)
				{
					byte b = (byte)bitStream_readFrom.ReadByte();
					bytes[i] = b;
				}
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = BitConverter.ToInt16(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(int).FullName)
				{
#>
				int count = 4;
				byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
				for (int i = 0; i < count; ++i)
				{
					byte b = (byte)bitStream_readFrom.ReadByte();
					bytes[i] = b;
				}
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = BitConverter.ToInt32(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(sbyte).FullName)
				{
#>
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = (sbyte)bitStream_readFrom.ReadByte();
<#
				}
                else if (singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
				int count = 8;
				byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
				for (int i = 0; i < count; ++i)
				{
					byte b = (byte)bitStream_readFrom.ReadByte();
					bytes[i] = b;
				}
				<#=single.componentTypeName#>.<#=singleMember.memberName#> = BitConverter.ToDouble(bytes, 0);
<#
				}
			}#>
			}
<#			++iOverall;
		}
	}
#>
        }

        /// <summary>
        ///  Deserializes a single value (using <paramref name="singleIndex"/> to know which) from <paramref name="bitStream_readFrom"/>
        ///  and uses them to modify appropriate member variables internally.
        /// </summary>
        internal override void DeserializeInitSingle(Utils.BitStream bitStream_readFrom, byte singleIndex, long assumedElapsedTicksAtChange)
        {
			switch (singleIndex)
			{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				case <#=iOverall#>:
				{ // <#=single.componentTypeName#>.<#=singleMember.memberName#>
<#
			string singleMember_memberTypeFullName = singleMember.memberTypeFullName;
			// switch () boo hoo no switch for string because teh case values are not constant!!!  TODO Must make the following more performant!
            {
				if (singleMember.attribute.CustomSerialize_Instance != null)
                {#>
					IGONetAutoMagicalSync_CustomSerializer customSerializer = GONetAutoMagicalSyncAttribute.GetCustomSerializer<<#=singleMember.attribute.CustomSerialize_Instance.GetType().FullName.Replace("+", ".")#>>(); // TODO need to cache this locally instead of having to lookup each time
					var value = (<#=singleMember.memberTypeFullName#>)customSerializer.Deserialize(bitStream_readFrom);
<#              }
				else if (singleMember_memberTypeFullName == typeof(bool).FullName)
                {
#>
					bool value;
					bitStream_readFrom.ReadBit(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(float).FullName)
				{
#>
					float value;
					bitStream_readFrom.ReadFloat(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(long).FullName)
				{
#>
					long value;
					bitStream_readFrom.ReadLong(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(uint).FullName)
				{
#>
					uint value;
					bitStream_readFrom.ReadUInt(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(string).FullName)
                {
#>
					string value;
					bitStream_readFrom.ReadString(out value);
<#
				}
				else if (singleMember_memberTypeFullName == typeof(byte).FullName)
				{
#>
					var value = (byte)bitStream_readFrom.ReadByte();
<#
				}
				else if (singleMember_memberTypeFullName == typeof(ushort).FullName)
				{
#>
					ushort value;
					bitStream_readFrom.ReadUShort(out value);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(short).FullName)
				{
#>
					int count = 2;
					byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
					for (int i = 0; i < count; ++i)
					{
						byte b = (byte)bitStream_readFrom.ReadByte();
						bytes[i] = b;
					}
					var value = BitConverter.ToInt16(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(int).FullName)
				{
#>
					int count = 4;
					byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
					for (int i = 0; i < count; ++i)
					{
						byte b = (byte)bitStream_readFrom.ReadByte();
						bytes[i] = b;
					}
					var value = BitConverter.ToInt32(bytes, 0);
<#
				}
                else if (singleMember_memberTypeFullName == typeof(sbyte).FullName)
				{
#>
					var value = (sbyte)bitStream_readFrom.ReadByte();
<#
				}
                else if (singleMember_memberTypeFullName == typeof(double).FullName)
				{
#>
					int count = 8;
					byte[] bytes = new byte[count];<# /* TODO: new byte array!!!! no no no, use pool here! */ #>
					for (int i = 0; i < count; ++i)
					{
						byte b = (byte)bitStream_readFrom.ReadByte();
						bytes[i] = b;
					}
					var value = BitConverter.ToDouble(bytes, 0);
<#
				}
			}#>
<#				if (singleMember.attribute.ShouldBlendBetweenValuesReceived)
				{#>
					valuesChangesSupport[<#=iOverall#>].AddToMostRecentChangeQueue_IfAppropriate((float)value, assumedElapsedTicksAtChange); // NOTE: this queue will be used each frame to blend between this value and others added there
<#				}
				else
				{#>
					<#=single.componentTypeName#>.<#=singleMember.memberName#> = value;
<#				}#>
				}
				break;

<#			++iOverall;
		}
	}
#>
			}
        }

		internal override void UpdateLastKnownValues(GONetMain.SyncBundleUniqueGrouping? onlyMatchIfUniqueGroupingMatches = default)
		{
<#
	iOverall = 0;
	singleCount = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName.Length;
	for (int iSingle = 0; iSingle < singleCount; ++iSingle)
	{
		GONetParticipant_ComponentsWithAutoSyncMembers_Single single = uniqueEntry.ComponentMemberNames_By_ComponentTypeFullName[iSingle];
		int singleMemberCount = single.autoSyncMembers.Length;
		for (int iSingleMember = 0; iSingleMember < singleMemberCount; ++iSingleMember)
        {
			GONetParticipant_ComponentsWithAutoSyncMembers_SingleMember singleMember = single.autoSyncMembers[iSingleMember];
#>
				var valuesChangesSupport<#=iOverall#> = valuesChangesSupport[<#=iOverall#>];
				if (DoesMatchUniqueGrouping(valuesChangesSupport<#=iOverall#>, onlyMatchIfUniqueGroupingMatches))
				{
					valuesChangesSupport<#=iOverall#>.lastKnownValue_previous = valuesChangesSupport<#=iOverall#>.lastKnownValue;
					valuesChangesSupport<#=iOverall#>.lastKnownValue = <#=single.componentTypeName#>.<#=singleMember.memberName#>;
				}

<#		
			iOverall++;
		}
	}
#>
		}
    }
}
