// GENERATED BY GONet - DO NOT EDIT
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using GONet;
using GONet.Utils;
using MemoryPack;

namespace GONet
{
    internal static class GONetGlobal_RpcIds
    {
        // Base class RPC IDs
        internal const uint GetFullRpcValidationReport_RpcId = 0xBCF6ED9A;

        // Derived class RPC IDs
        internal const uint RPC_RequestLoadScene_RpcId = 0x29C207C3;
        internal const uint RPC_RequestUnloadScene_RpcId = 0xDB406D9E;
        internal const uint RPC_SceneRequestResponse_RpcId = 0xD6DE9EDA;
        internal const uint RPC_SyncSceneDefinedObjectIds_RpcId = 0x7B1327B9;
    }

    internal static class GONetGlobal_RpcInitializer
    {
        [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Initialize()
        {
            GONetGlobal_RpcDispatcher.EnsureInitialized();
        }
    }

    internal class GONetGlobal_RpcDispatcher : IRpcDispatcher
    {
        private static bool isInitialized = false;

        private const string RPC_REQUESTLOADSCENE = nameof(GONetGlobal.RPC_RequestLoadScene);
        private const string RPC_REQUESTUNLOADSCENE = nameof(GONetGlobal.RPC_RequestUnloadScene);
        private const string RPC_SCENEREQUESTRESPONSE = nameof(GONetGlobal.RPC_SceneRequestResponse);
        private const string RPC_SYNCSCENEDEFINEDOBJECTIDS = nameof(GONetGlobal.RPC_SyncSceneDefinedObjectIds);

        // Property accessor delegates for single targets
        private static readonly Dictionary<string, Func<object, ushort>> TargetPropertyAccessors = 
            new Dictionary<string, Func<object, ushort>>
        {
            { nameof(GONet.GONetGlobal.RPC_RequestLoadScene), 
              (obj) => ((GONet.GONetGlobal)obj).ServerAuthorityId },
            { nameof(GONet.GONetGlobal.RPC_RequestUnloadScene), 
              (obj) => ((GONet.GONetGlobal)obj).ServerAuthorityId },
        };

        // Property accessor delegates for multiple targets (fills buffer, returns count)
        private static readonly Dictionary<string, Func<object, ushort[], int>> MultiTargetPropertyAccessors = 
            new Dictionary<string, Func<object, ushort[], int>>
        {
        };

        // Parameter count metadata for validators (sync and async)
        private static readonly Dictionary<string, int> ValidatorParameterCounts = 
            new Dictionary<string, int>
        {
            { nameof(GONetGlobal.RPC_RequestLoadScene), 3 },
            { nameof(GONetGlobal.RPC_RequestUnloadScene), 1 },
        };

        // SYNC validation delegates (RpcValidationResult with ref parameters)
        private static readonly Dictionary<string, object> EnhancedValidators = 
            new Dictionary<string, object>
        {
            { nameof(GONetGlobal.RPC_RequestLoadScene),
              (Func<object, ushort, ushort[], int, byte[], RpcValidationResult>)((obj, source, targets, count, data) =>
              {
                  var instance = (GONetGlobal)obj;
                  var result = RpcValidationResult.CreatePreAllocated(count);
                  
                  var validationContext = new RpcValidationContext
                  {
                      SourceAuthorityId = source,
                      TargetAuthorityIds = targets,
                      TargetCount = count,
                      PreAllocatedResult = result
                  };
                  
                  try
                  {
                      GONetMain.EventBus.SetValidationContext(validationContext);
                      var args = SerializationUtils.DeserializeFromBytes<GONetGlobal_RPC_RequestLoadScene_RpcData>(data);
                      var sceneName = args.sceneName;
                      var modeRaw = args.modeRaw;
                      var loadTypeRaw = args.loadTypeRaw;
                      result = instance.Validate_RequestLoadScene(ref sceneName, ref modeRaw, ref loadTypeRaw);
                      
                      if (result.WasModified)
                      {
                          args.sceneName = sceneName;
                          args.modeRaw = modeRaw;
                          args.loadTypeRaw = loadTypeRaw;
                          int bytesUsed;
                          bool needsReturn;
                          result.ModifiedData = SerializationUtils.SerializeToBytes(args, out bytesUsed, out needsReturn);
                      }
                      return result;
                  }
                  finally
                  {
                      GONetMain.EventBus.ClearValidationContext();
                  }
              })
            },
            { nameof(GONetGlobal.RPC_RequestUnloadScene),
              (Func<object, ushort, ushort[], int, byte[], RpcValidationResult>)((obj, source, targets, count, data) =>
              {
                  var instance = (GONetGlobal)obj;
                  var result = RpcValidationResult.CreatePreAllocated(count);
                  
                  var validationContext = new RpcValidationContext
                  {
                      SourceAuthorityId = source,
                      TargetAuthorityIds = targets,
                      TargetCount = count,
                      PreAllocatedResult = result
                  };
                  
                  try
                  {
                      GONetMain.EventBus.SetValidationContext(validationContext);
                      var args = SerializationUtils.DeserializeFromBytes<GONetGlobal_RPC_RequestUnloadScene_RpcData>(data);
                      var sceneName = args.sceneName;
                      result = instance.Validate_RequestUnloadScene(ref sceneName);
                      
                      if (result.WasModified)
                      {
                          args.sceneName = sceneName;
                          int bytesUsed;
                          bool needsReturn;
                          result.ModifiedData = SerializationUtils.SerializeToBytes(args, out bytesUsed, out needsReturn);
                      }
                      return result;
                  }
                  finally
                  {
                      GONetMain.EventBus.ClearValidationContext();
                  }
              })
            },
        };

        public static readonly Dictionary<string, RpcMetadata> Metadata = new Dictionary<string, RpcMetadata>
        {
            // Base class RPCs
            { nameof(GONetParticipantCompanionBehaviour.GetFullRpcValidationReport), new RpcMetadata { 
                Type = RpcType.ServerRpc, 
                IsReliable = true, 
                IsMineRequired = true, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            // Derived class RPCs
            { nameof(GONet.GONetGlobal.RPC_RequestLoadScene), new RpcMetadata { 
                Type = RpcType.TargetRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.SpecificAuthority, 
                TargetPropertyName = "ServerAuthorityId",
                IsMultipleTargets = false,
                ValidationMethodName = "Validate_RequestLoadScene",
                ExpectsDeliveryReport = true
            }},
            { nameof(GONet.GONetGlobal.RPC_RequestUnloadScene), new RpcMetadata { 
                Type = RpcType.TargetRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.SpecificAuthority, 
                TargetPropertyName = "ServerAuthorityId",
                IsMultipleTargets = false,
                ValidationMethodName = "Validate_RequestUnloadScene",
                ExpectsDeliveryReport = false
            }},
            { nameof(GONet.GONetGlobal.RPC_SceneRequestResponse), new RpcMetadata { 
                Type = RpcType.TargetRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            { nameof(GONet.GONetGlobal.RPC_SyncSceneDefinedObjectIds), new RpcMetadata { 
                Type = RpcType.TargetRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
        };

        public void Dispatch0(object instance, string methodName)
        {
        }

        public void Dispatch1<T1>(object instance, string methodName, T1 arg1)
        {
            var typed = (GONet.GONetGlobal)instance;
            switch (methodName)
            {
                case RPC_REQUESTUNLOADSCENE:
                    typed.RPC_RequestUnloadScene((System.String)(object)arg1);
                    break;
            }
        }

        public void Dispatch2<T1, T2>(object instance, string methodName, T1 arg1, T2 arg2)
        {
        }

        public void Dispatch3<T1, T2, T3>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3)
        {
            var typed = (GONet.GONetGlobal)instance;
            switch (methodName)
            {
                case RPC_REQUESTLOADSCENE:
                    break;
            }
        }

        public void Dispatch4<T1, T2, T3, T4>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            var typed = (GONet.GONetGlobal)instance;
            switch (methodName)
            {
                case RPC_SCENEREQUESTRESPONSE:
                    typed.RPC_SceneRequestResponse((System.UInt16)(object)arg1, (System.Boolean)(object)arg2, (System.String)(object)arg3, (System.String)(object)arg4);
                    break;
                case RPC_SYNCSCENEDEFINEDOBJECTIDS:
                    typed.RPC_SyncSceneDefinedObjectIds((System.UInt16)(object)arg1, (System.String)(object)arg2, (System.String[])(object)arg3, (System.UInt32[])(object)arg4);
                    break;
            }
        }

        public void Dispatch5<T1, T2, T3, T4, T5>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
        }

        public void Dispatch6<T1, T2, T3, T4, T5, T6>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
        }

        public void Dispatch7<T1, T2, T3, T4, T5, T6, T7>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
        }

        public void Dispatch8<T1, T2, T3, T4, T5, T6, T7, T8>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
        }

        public async Task<TResult> DispatchAsync0<TResult>(object instance, string methodName)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync1<TResult, T1>(object instance, string methodName, T1 arg1)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync2<TResult, T1, T2>(object instance, string methodName, T1 arg1, T2 arg2)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync3<TResult, T1, T2, T3>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3)
        {
            var typed = (GONet.GONetGlobal)instance;
            switch (methodName)
            {
                case RPC_REQUESTLOADSCENE:
                    return (TResult)(object)await typed.RPC_RequestLoadScene((System.String)(object)arg1, (System.Byte)(object)arg2, (System.Byte)(object)arg3);
                default:
                    return default(TResult);
            }
        }

        public async Task<TResult> DispatchAsync4<TResult, T1, T2, T3, T4>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync5<TResult, T1, T2, T3, T4, T5>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync6<TResult, T1, T2, T3, T4, T5, T6>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync7<TResult, T1, T2, T3, T4, T5, T6, T7>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync8<TResult, T1, T2, T3, T4, T5, T6, T7, T8>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            return default(TResult);
        }


        static GONetGlobal_RpcDispatcher()
        {
            if (!isInitialized)
            {
                isInitialized = true;
                GONetMain.EventBus.RegisterRpcIdMapping(0xBCF6ED9A, nameof(GONetParticipantCompanionBehaviour.GetFullRpcValidationReport), typeof(GONetGlobal));
                GONetMain.EventBus.RegisterRpcIdMapping(0x29C207C3, nameof(GONetGlobal.RPC_RequestLoadScene), typeof(GONetGlobal));
                GONetMain.EventBus.RegisterRpcIdMapping(0xDB406D9E, nameof(GONetGlobal.RPC_RequestUnloadScene), typeof(GONetGlobal));
                GONetMain.EventBus.RegisterRpcIdMapping(0xD6DE9EDA, nameof(GONetGlobal.RPC_SceneRequestResponse), typeof(GONetGlobal));
                GONetMain.EventBus.RegisterRpcIdMapping(0x7B1327B9, nameof(GONetGlobal.RPC_SyncSceneDefinedObjectIds), typeof(GONetGlobal));
                GONetMain.EventBus.RegisterRpcDispatcher(typeof(GONetGlobal), new GONetGlobal_RpcDispatcher());
                GONetMain.EventBus.RegisterRpcMetadata(typeof(GONetGlobal), Metadata);
                if (TargetPropertyAccessors.Count > 0)
                    GONetMain.EventBus.RegisterTargetPropertyAccessors(typeof(GONetGlobal), TargetPropertyAccessors);
                if (MultiTargetPropertyAccessors.Count > 0)
                    GONetMain.EventBus.RegisterMultiTargetPropertyAccessors(typeof(GONetGlobal), MultiTargetPropertyAccessors);
                if (EnhancedValidators != null && EnhancedValidators.Count > 0)
                    GONetMain.EventBus.RegisterEnhancedValidators(typeof(GONetGlobal), EnhancedValidators, ValidatorParameterCounts);
                RegisterRpcHandlers();
                GONetLog.Debug("Initialized RPC dispatcher for GONetGlobal");
            }
        }

        internal static void EnsureInitialized()
        {
            _ = Metadata;
        }

        private static void RegisterRpcHandlers()
        {
            var eventBus = GONetMain.EventBus;
            eventBus.RegisterRpcHandler(GONetGlobal_RpcIds.RPC_RequestLoadScene_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<GONetGlobal>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                // NO more route VALIDATION HERE - if we received it, we're a valid target!
                // The server already validated during routing

                var args = SerializationUtils.DeserializeFromBytes<GONetGlobal_RPC_RequestLoadScene_RpcData>(rpcEvent.Data);
                var result = await instance.RPC_RequestLoadScene(args.sceneName, args.modeRaw, args.loadTypeRaw);

                // Only send response to remote clients, not to server itself
                if (rpcEvent.CorrelationId != 0 && envelope.SourceAuthorityId != GONetMain.MyAuthorityId)
                {
                    int bytesUsed;
                    bool needsReturn;
                    byte[] responseData = SerializationUtils.SerializeToBytes(result, out bytesUsed, out needsReturn);

                    var response = RpcResponseEvent.Borrow();
                    response.OccurredAtElapsedTicks = GONetMain.Time.ElapsedTicks;
                    response.CorrelationId = rpcEvent.CorrelationId;
                    response.Success = true;
                    response.Data = responseData;

                    eventBus.Publish(response, targetClientAuthorityId: envelope.SourceAuthorityId, shouldPublishReliably: true);
                    // Publish auto-returns the event and the data
                }
            });
            eventBus.RegisterRpcHandler(GONetGlobal_RpcIds.RPC_RequestUnloadScene_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<GONetGlobal>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                // NO more route VALIDATION HERE - if we received it, we're a valid target!
                // The server already validated during routing

                var args = SerializationUtils.DeserializeFromBytes<GONetGlobal_RPC_RequestUnloadScene_RpcData>(rpcEvent.Data);
                instance.RPC_RequestUnloadScene(args.sceneName);
            });
            eventBus.RegisterRpcHandler(GONetGlobal_RpcIds.RPC_SceneRequestResponse_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<GONetGlobal>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                // NO more route VALIDATION HERE - if we received it, we're a valid target!
                // The server already validated during routing

                var args = SerializationUtils.DeserializeFromBytes<GONetGlobal_RPC_SceneRequestResponse_RpcData>(rpcEvent.Data);
                instance.RPC_SceneRequestResponse(args.targetClientId, args.approved, args.sceneName, args.denialReason);
            });
            eventBus.RegisterRpcHandler(GONetGlobal_RpcIds.RPC_SyncSceneDefinedObjectIds_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<GONetGlobal>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                // NO more route VALIDATION HERE - if we received it, we're a valid target!
                // The server already validated during routing

                var args = SerializationUtils.DeserializeFromBytes<GONetGlobal_RPC_SyncSceneDefinedObjectIds_RpcData>(rpcEvent.Data);
                instance.RPC_SyncSceneDefinedObjectIds(args.targetClientId, args.sceneName, args.designTimeLocations, args.gonetIds);
            });
        }
    }

    [MemoryPackable]
    public partial struct GONetGlobal_RPC_RequestLoadScene_RpcData
    {
        public System.String sceneName { get; set; }
        public System.Byte modeRaw { get; set; }
        public System.Byte loadTypeRaw { get; set; }
    }

    [MemoryPackable]
    public partial struct GONetGlobal_RPC_RequestUnloadScene_RpcData
    {
        public System.String sceneName { get; set; }
    }

    [MemoryPackable]
    public partial struct GONetGlobal_RPC_SceneRequestResponse_RpcData
    {
        public System.UInt16 targetClientId { get; set; }
        public System.Boolean approved { get; set; }
        public System.String sceneName { get; set; }
        public System.String denialReason { get; set; }
    }

    [MemoryPackable]
    public partial struct GONetGlobal_RPC_SyncSceneDefinedObjectIds_RpcData
    {
        public System.UInt16 targetClientId { get; set; }
        public System.String sceneName { get; set; }
        public System.String[] designTimeLocations { get; set; }
        public System.UInt32[] gonetIds { get; set; }
    }

}
