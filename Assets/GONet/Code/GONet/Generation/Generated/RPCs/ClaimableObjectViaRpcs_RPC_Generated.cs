// GENERATED BY GONet - DO NOT EDIT
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using GONet;
using GONet.Utils;
using MemoryPack;

namespace GONet
{
    internal static class ClaimableObjectViaRpcs_RpcIds
    {
        // Base class RPC IDs
        internal const uint GetFullRpcValidationReport_RpcId = 0xBCF6ED9A;

        // Derived class RPC IDs
        internal const uint BroadcastClaimChanged_RpcId = 0x105F6D85;
        internal const uint NotifyAttemptedClaimWhileOwned_RpcId = 0xC1B305D1;
        internal const uint NotifyClaimerOfAttemptedTheft_RpcId = 0xAB259852;
        internal const uint RequestClaim_RpcId = 0x42EBE829;
        internal const uint RequestRelease_RpcId = 0xF9A43F0C;
    }

    internal static class ClaimableObjectViaRpcs_RpcInitializer
    {
        [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Initialize()
        {
            ClaimableObjectViaRpcs_RpcDispatcher.EnsureInitialized();
        }
    }

    internal class ClaimableObjectViaRpcs_RpcDispatcher : IRpcDispatcher
    {
        private static bool isInitialized = false;

        private const string BROADCASTCLAIMCHANGED = nameof(ClaimableObjectViaRpcs.BroadcastClaimChanged);
        private const string NOTIFYATTEMPTEDCLAIMWHILEOWNED = nameof(ClaimableObjectViaRpcs.NotifyAttemptedClaimWhileOwned);
        private const string NOTIFYCLAIMEROFATTEMPTEDTHEFT = nameof(ClaimableObjectViaRpcs.NotifyClaimerOfAttemptedTheft);
        private const string REQUESTCLAIM = nameof(ClaimableObjectViaRpcs.RequestClaim);
        private const string REQUESTRELEASE = nameof(ClaimableObjectViaRpcs.RequestRelease);

        // Property accessor delegates for single targets
        private static readonly Dictionary<string, Func<object, ushort>> TargetPropertyAccessors = 
            new Dictionary<string, Func<object, ushort>>
        {
            { nameof(ClaimableObjectViaRpcs.NotifyClaimerOfAttemptedTheft), 
              (obj) => ((ClaimableObjectViaRpcs)obj).ClaimedByAuthorityId },
        };

        // Property accessor delegates for multiple targets (fills buffer, returns count)
        private static readonly Dictionary<string, Func<object, ushort[], int>> MultiTargetPropertyAccessors = 
            new Dictionary<string, Func<object, ushort[], int>>
        {
        };

        // Parameter count metadata for validators (sync and async)
        private static readonly Dictionary<string, int> ValidatorParameterCounts = 
            new Dictionary<string, int>
        {
        };

        public static readonly Dictionary<string, RpcMetadata> Metadata = new Dictionary<string, RpcMetadata>
        {
            // Base class RPCs
            { nameof(GONetParticipantCompanionBehaviour.GetFullRpcValidationReport), new RpcMetadata { 
                Type = RpcType.ServerRpc, 
                IsReliable = true, 
                IsMineRequired = true, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            // Derived class RPCs
            { nameof(ClaimableObjectViaRpcs.BroadcastClaimChanged), new RpcMetadata { 
                Type = RpcType.ClientRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = true, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            { nameof(ClaimableObjectViaRpcs.NotifyAttemptedClaimWhileOwned), new RpcMetadata { 
                Type = RpcType.ServerRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            { nameof(ClaimableObjectViaRpcs.NotifyClaimerOfAttemptedTheft), new RpcMetadata { 
                Type = RpcType.TargetRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.SpecificAuthority, 
                TargetPropertyName = "ClaimedByAuthorityId",
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            { nameof(ClaimableObjectViaRpcs.RequestClaim), new RpcMetadata { 
                Type = RpcType.ServerRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
            { nameof(ClaimableObjectViaRpcs.RequestRelease), new RpcMetadata { 
                Type = RpcType.ServerRpc, 
                IsReliable = true, 
                IsMineRequired = false, 
                IsPersistent = false, 
                Target = RpcTarget.All, 
                TargetPropertyName = null,
                IsMultipleTargets = false,
                ValidationMethodName = null,
                ExpectsDeliveryReport = false
            }},
        };

        public void Dispatch0(object instance, string methodName)
        {
            var typed = (ClaimableObjectViaRpcs)instance;
            switch (methodName)
            {
                case NOTIFYATTEMPTEDCLAIMWHILEOWNED:
                    typed.NotifyAttemptedClaimWhileOwned();
                    break;
                case REQUESTCLAIM:
                    break;
                case REQUESTRELEASE:
                    break;
            }
        }

        public void Dispatch1<T1>(object instance, string methodName, T1 arg1)
        {
            var typed = (ClaimableObjectViaRpcs)instance;
            switch (methodName)
            {
                case NOTIFYCLAIMEROFATTEMPTEDTHEFT:
                    typed.NotifyClaimerOfAttemptedTheft((System.UInt16)(object)arg1);
                    break;
            }
        }

        public void Dispatch2<T1, T2>(object instance, string methodName, T1 arg1, T2 arg2)
        {
            var typed = (ClaimableObjectViaRpcs)instance;
            switch (methodName)
            {
                case BROADCASTCLAIMCHANGED:
                    typed.BroadcastClaimChanged((System.UInt16)(object)arg1, (System.Boolean)(object)arg2);
                    break;
            }
        }

        public void Dispatch3<T1, T2, T3>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3)
        {
        }

        public void Dispatch4<T1, T2, T3, T4>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
        }

        public void Dispatch5<T1, T2, T3, T4, T5>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
        }

        public void Dispatch6<T1, T2, T3, T4, T5, T6>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
        }

        public void Dispatch7<T1, T2, T3, T4, T5, T6, T7>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
        }

        public void Dispatch8<T1, T2, T3, T4, T5, T6, T7, T8>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
        }

        public async Task<TResult> DispatchAsync0<TResult>(object instance, string methodName)
        {
            var typed = (ClaimableObjectViaRpcs)instance;
            switch (methodName)
            {
                case REQUESTCLAIM:
                    return (TResult)(object)await typed.RequestClaim();
                case REQUESTRELEASE:
                    return (TResult)(object)await typed.RequestRelease();
                default:
                    return default(TResult);
            }
        }

        public async Task<TResult> DispatchAsync1<TResult, T1>(object instance, string methodName, T1 arg1)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync2<TResult, T1, T2>(object instance, string methodName, T1 arg1, T2 arg2)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync3<TResult, T1, T2, T3>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync4<TResult, T1, T2, T3, T4>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync5<TResult, T1, T2, T3, T4, T5>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync6<TResult, T1, T2, T3, T4, T5, T6>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync7<TResult, T1, T2, T3, T4, T5, T6, T7>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            return default(TResult);
        }

        public async Task<TResult> DispatchAsync8<TResult, T1, T2, T3, T4, T5, T6, T7, T8>(object instance, string methodName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            return default(TResult);
        }


        static ClaimableObjectViaRpcs_RpcDispatcher()
        {
            if (!isInitialized)
            {
                isInitialized = true;
                GONetMain.EventBus.RegisterRpcIdMapping(0xBCF6ED9A, nameof(GONetParticipantCompanionBehaviour.GetFullRpcValidationReport), typeof(ClaimableObjectViaRpcs));
                GONetMain.EventBus.RegisterRpcIdMapping(0x105F6D85, nameof(ClaimableObjectViaRpcs.BroadcastClaimChanged), typeof(ClaimableObjectViaRpcs));
                GONetMain.EventBus.RegisterRpcIdMapping(0xC1B305D1, nameof(ClaimableObjectViaRpcs.NotifyAttemptedClaimWhileOwned), typeof(ClaimableObjectViaRpcs));
                GONetMain.EventBus.RegisterRpcIdMapping(0xAB259852, nameof(ClaimableObjectViaRpcs.NotifyClaimerOfAttemptedTheft), typeof(ClaimableObjectViaRpcs));
                GONetMain.EventBus.RegisterRpcIdMapping(0x42EBE829, nameof(ClaimableObjectViaRpcs.RequestClaim), typeof(ClaimableObjectViaRpcs));
                GONetMain.EventBus.RegisterRpcIdMapping(0xF9A43F0C, nameof(ClaimableObjectViaRpcs.RequestRelease), typeof(ClaimableObjectViaRpcs));
                GONetMain.EventBus.RegisterRpcDispatcher(typeof(ClaimableObjectViaRpcs), new ClaimableObjectViaRpcs_RpcDispatcher());
                GONetMain.EventBus.RegisterRpcMetadata(typeof(ClaimableObjectViaRpcs), Metadata);
                if (TargetPropertyAccessors.Count > 0)
                    GONetMain.EventBus.RegisterTargetPropertyAccessors(typeof(ClaimableObjectViaRpcs), TargetPropertyAccessors);
                if (MultiTargetPropertyAccessors.Count > 0)
                    GONetMain.EventBus.RegisterMultiTargetPropertyAccessors(typeof(ClaimableObjectViaRpcs), MultiTargetPropertyAccessors);
                RegisterRpcHandlers();
                GONetLog.Debug("Initialized RPC dispatcher for ClaimableObjectViaRpcs");
            }
        }

        internal static void EnsureInitialized()
        {
            _ = Metadata;
        }

        private static void RegisterRpcHandlers()
        {
            var eventBus = GONetMain.EventBus;
            eventBus.RegisterRpcHandler(ClaimableObjectViaRpcs_RpcIds.BroadcastClaimChanged_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<ClaimableObjectViaRpcs>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                var args = SerializationUtils.DeserializeFromBytes<ClaimableObjectViaRpcs_BroadcastClaimChanged_RpcData>(rpcEvent.Data);
                instance.BroadcastClaimChanged(args.authorityId, args.wasClaimed);
            });
            eventBus.RegisterRpcHandler(ClaimableObjectViaRpcs_RpcIds.NotifyAttemptedClaimWhileOwned_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<ClaimableObjectViaRpcs>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                instance.NotifyAttemptedClaimWhileOwned();
            });
            eventBus.RegisterRpcHandler(ClaimableObjectViaRpcs_RpcIds.NotifyClaimerOfAttemptedTheft_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<ClaimableObjectViaRpcs>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                // NO more route VALIDATION HERE - if we received it, we're a valid target!
                // The server already validated during routing

                var args = SerializationUtils.DeserializeFromBytes<ClaimableObjectViaRpcs_NotifyClaimerOfAttemptedTheft_RpcData>(rpcEvent.Data);
                instance.NotifyClaimerOfAttemptedTheft(args.attemptingAuthorityId);
            });
            eventBus.RegisterRpcHandler(ClaimableObjectViaRpcs_RpcIds.RequestClaim_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<ClaimableObjectViaRpcs>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                var result = await instance.RequestClaim();

                // Only send response to remote clients, not to server itself
                if (rpcEvent.CorrelationId != 0 && envelope.SourceAuthorityId != GONetMain.MyAuthorityId)
                {
                    int bytesUsed;
                    bool needsReturn;
                    byte[] responseData = SerializationUtils.SerializeToBytes(result, out bytesUsed, out needsReturn);

                    var response = RpcResponseEvent.Borrow();
                    response.OccurredAtElapsedTicks = GONetMain.Time.ElapsedTicks;
                    response.CorrelationId = rpcEvent.CorrelationId;
                    response.Success = true;
                    response.Data = responseData;

                    eventBus.Publish(response, targetClientAuthorityId: envelope.SourceAuthorityId, shouldPublishReliably: true);
                    // Publish auto-returns the event and the data
                }
            });
            eventBus.RegisterRpcHandler(ClaimableObjectViaRpcs_RpcIds.RequestRelease_RpcId, async (envelope) =>
            {
                var rpcEvent = envelope.Event;
                var gnp = GONetMain.GetGONetParticipantById(rpcEvent.GONetId);
                var instance = gnp?.GetComponent<ClaimableObjectViaRpcs>();
                
                // CRITICAL: If participant exists but component doesn't, throw exception to trigger deferral
                // This handles runtime-added components that receive RPCs before they're initialized
                if (instance == null)
                {
                    if (gnp != null)
                    {
                        throw new GONetEventBus.RpcComponentNotReadyException(rpcEvent.GONetId, rpcEvent.RpcId);
                    }
                    return; // Participant doesn't exist - silently ignore
                }

                var result = await instance.RequestRelease();

                // Only send response to remote clients, not to server itself
                if (rpcEvent.CorrelationId != 0 && envelope.SourceAuthorityId != GONetMain.MyAuthorityId)
                {
                    int bytesUsed;
                    bool needsReturn;
                    byte[] responseData = SerializationUtils.SerializeToBytes(result, out bytesUsed, out needsReturn);

                    var response = RpcResponseEvent.Borrow();
                    response.OccurredAtElapsedTicks = GONetMain.Time.ElapsedTicks;
                    response.CorrelationId = rpcEvent.CorrelationId;
                    response.Success = true;
                    response.Data = responseData;

                    eventBus.Publish(response, targetClientAuthorityId: envelope.SourceAuthorityId, shouldPublishReliably: true);
                    // Publish auto-returns the event and the data
                }
            });
        }
    }

    [MemoryPackable]
    public partial struct ClaimableObjectViaRpcs_BroadcastClaimChanged_RpcData
    {
        public System.UInt16 authorityId { get; set; }
        public System.Boolean wasClaimed { get; set; }
    }

    [MemoryPackable]
    public partial struct ClaimableObjectViaRpcs_NotifyClaimerOfAttemptedTheft_RpcData
    {
        public System.UInt16 attemptingAuthorityId { get; set; }
    }

}
